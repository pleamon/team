# 团队协议（SSOT）

version: 1.0.0

> 本文件是团队协作规则的**唯一真相来源**。所有 Agent 配置引用此文件，不再各自重复定义。

---

## 1. 团队成员

> 完整成员列表参见 `skills/team-roster/SKILL.md`（唯一维护点）。

---

## 2. @mention 纪律

### 核心规则

> **只有在需要对方在当前线程回复或行动时**，才使用 `<@UXXXXXXXX>` 格式。

| 场景 | 做法 | 示例 |
|------|------|------|
| 需要对方回复/行动 | 用 `<@U...>` | `<@U0AAPB65K0F> 新任务：用户注册功能 PRD` |
| 仅背景提及/不需要回复 | 用文本名称 | `这个任务涉及 Atath 和 FE 的协作` |
| 不确定是否需要 @ | **默认不 @** | 等确实需要对方介入时再 @ |

### 典型需要 @ 的场景

- 下达新任务
- 需要对方确认/审核
- 阻塞问题需要对方解除
- 故障需要协同处理

### 典型不需要 @ 的场景

- 同步进展信息（仅通知，不需要回复）
- 背景说明中提到某个 Agent
- 已完成的任务汇总中提及协作方

---

## 3. 通信规范

### 3.1 频道用途

| 频道 | 用途 | 参与者 |
|------|------|--------|
| #team-hub | 全员协调、重要公告、跨角色协作 | 全员 |
| #dev | 开发讨论、技术问题、接口联调 | FE/BE/Arch/DBA |
| #design | 设计讨论、设计评审、还原度验收 | UIUX/PM/FE |
| #ops | 运维讨论、部署通知、故障处理 | Infra/QA/BE |
| #random | 闲聊、非工作话题 | 全员（可选） |

### 3.2 Thread 使用规范

#### 必须用 Thread 的场景

- 任务讨论（从"收到"到"验收完成"）
- 技术问题讨论（超过 2 轮来回）
- 审核反馈

#### 直接发频道消息的场景

- 新任务下达（首条消息在频道，后续在 thread）
- 重要公告
- 故障通报

#### 禁止

- ❌ 在多个 thread 中讨论同一个任务
- ❌ 在频道中进行超过 2 轮的讨论（应转入 thread）

### 3.3 消息模板

#### 任务下达模板

```
@{Agent} 新任务：

**背景**：{为什么需要做}
**目标**：{完成后达到的状态}
**验收标准**：
- {可检查的条件1}
- {可检查的条件2}
**产出**：{Git 提交 或 Slack 回复内容}
**截止**：{时间要求}
```

#### 完成回复模板

```
@{任务发起方} 任务完成：

**产出**：
- {做了什么}
- {关键决策}

**Git**：{仓库/分支/commit}

**未解决问题**：{如有}
```

#### 升级消息模板

```
@{上级} 升级：

**问题**：{什么问题}
**影响**：{阻塞什么、影响范围}
**已尝试**：{做了什么尝试}
**需要**：{需要什么帮助/决策}
```

#### 故障通报模板

```
🚨 故障通报

**影响**：{哪些服务/用户受影响}
**现象**：{故障表现}
**状态**：{处理中/已恢复}
**跟进**：@{负责人}
```

### 3.4 响应时效

| 消息类型 | 期望响应时间 |
|---------|------------|
| 🚨 紧急/故障 | 15 分钟内 |
| @mention 任务 | 1 小时内 |
| 一般问题 | 4 小时内 |

#### 收到任务时

必须回复确认：
```
收到，预计 {时间} 完成。
```
或
```
收到。有疑问：{问题}
```

#### 无法及时处理时

```
收到，当前在处理 {其他任务}，预计 {时间} 开始。
```

---

## 4. 上下文传递协议

### 4.1 下达任务时的必备上下文

每条任务消息必须包含足够的上下文，让接收方无需翻聊天记录即可理解并执行。

| 类型 | 内容 | 必填 |
|------|------|------|
| 背景 | 为什么做这件事 | ✅ |
| 目标 | 做成什么样 | ✅ |
| 验收标准 | 可检查的完成条件 | ✅ |
| 前置产出 | 相关 PRD / 设计稿 / API 契约的 thread permalink 或 Git 路径 | 有则必填 |

### 4.2 转发任务时保留原始上下文

当 Agent A 收到任务后需要分解给 Agent B 时：

- **必须**包含原始任务的 thread permalink
- **必须**说明"这是 [原始发起人] 需要的 [总体目标] 的一部分"
- **禁止**只转发结论不转发背景

### 4.3 回复时引用原始请求

- 完成回复时，必须引用原始任务消息（用 Slack quote 或 thread permalink）
- 让发起方一眼看到"你做的是哪个任务"

---

## 5. 任务生命周期协议

### 5.1 任务标识

- 使用 Slack thread 作为任务载体，每个任务一个 thread
- 所有后续讨论、进度更新、完成通知都在同一 thread 中

### 5.2 生命周期

```
发起 → 确认收到（≤15min）→ [进度更新] → 完成通知 → 验收
```

### 5.3 确认超时处理

| 时间 | 动作 |
|------|------|
| 15 分钟内 | 无"收到"回复 → 再次 @mention |
| 30 分钟 | 仍无回复 → 升级给上级 |

- **禁止"发了就忘"**：下达任务后必须跟踪确认。

### 5.4 进度更新规范

预计超过 2 小时的任务，每完成一个关键步骤发一次进度更新：

```
🚧 进度：[已完成步骤] / [总步骤]，当前在做 [什么]
```

### 5.5 完成验收闭环

- Agent 完成后 @mention 发起方 + 附产出
- 发起方必须在 thread 内回复 ✅ 或反馈
- **未验收的任务不算完成**

---

## 6. 协作架构

### 6.1 三层决策架构

```
第1层（战略）：Alex ↔ Pleamon
  - 项目目标、重大决策、风险管理

第2层（战术）：Alex ↔ Atath
  - Sprint 管理、任务分配、进度跟踪

第3层（执行）：Atath ↔ 其他 Agents
  - 具体任务执行、代码实现、设计产出
```

### 6.2 直接技术协作通道

#### 原则

任务分配走 Atath（PM），**技术问题直接找对应 Agent**。

#### 允许直接 @mention 的场景（无需经过 Atath）

| 发起方 | 可直接联系 | 场景 |
|--------|-----------|------|
| FE | UIUX | 设计规范澄清、还原度讨论 |
| FE | BE | 接口联调、API 问题 |
| FE | Arch | API 契约疑问 |
| BE | Arch | 契约疑问、技术方案讨论 |
| BE | DBA | Schema 问题、数据需求 |
| Arch | DBA | 数据模型协作 |
| 任何 Agent | QA | 提交审核 |

#### 必须经过 Atath 的场景

- 新任务分配
- 需求变更
- 优先级调整
- 跨多个 Agent 的协调

#### 直接协作的规则

- 在相关频道（#dev / #design / #ops）进行，不私聊
- 结果需在 thread 中总结，方便 Atath 追踪
- 如果直接协作无法解决 → 升级给 Atath

### 6.3 升级规则

```
执行问题 → 升级给 Atath（PM）
战术问题 → 升级给 Alex（Chief）
战略问题 → Alex 升级给 Pleamon
```

### 6.4 冲突解决协议

#### 技术分歧

1. 双方在 thread 中各陈述方案 + 理由
2. 15 分钟内无法达成一致 → @mention Arch 仲裁
3. Arch 也无法决定 → 升级给 Alex

#### 需求理解分歧

1. 回到 PRD 原文
2. 无法从 PRD 解答 → @mention Atath 澄清

#### 原则：谁的领域谁说了算

| 领域 | 决策者 |
|------|--------|
| 设计问题 | UIUX |
| API 契约 | Arch |
| Schema | DBA |
| 需求范围 | Atath |
| 战略方向 | Alex |

---

## 7. 决策分级

| 级别 | 决策者 | 示例 |
|-----|-------|------|
| 战略级 | Alex（或升级 Pleamon） | 技术栈、架构方向、重大重构 |
| 战术级 | Atath（可自主） | 任务优先级、Sprint 范围 |
| 执行级 | 各 Agent（可自主） | 代码实现、组件设计 |

---

## 8. 质量标准

### 8.1 状态标记

| 标记 | 含义 |
|------|------|
| ✅ | 完成 |
| 🚧 | 进行中 |
| 🔴 | 阻塞/紧急 |
| ⚠️ | 警告/注意 |
| 💡 | 建议/想法 |
| 🚨 | 紧急/故障 |

### 8.2 优先级定义

| 优先级 | 含义 |
|--------|------|
| P0 | 阻塞发布 |
| P1 | 本周 |
| P2 | 本迭代 |
| P3 | 排期 |

### 8.3 日期格式

统一使用 `YYYY-MM-DD`。

### 8.4 禁止行为

- ❌ 私聊传达任务（应在公开频道，可追溯）
- ❌ @mention 后不等回复就继续（确认对方收到）
- ❌ 发长篇大论不加结构（用标题、列表）
- ❌ 重要信息只发一次不确认（无回复需追问）
- ❌ 故障/紧急问题不 @mention 相关人
- ❌ **发起或参加会议/Huddle**（Agent 是异步协作的，详见 §9）
- ❌ **讨论"谁几点有空"、协调会议时间**（直接在 thread 中异步解决）

---

## 9. 协作模式基础

### 核心前提：Agent 是异步的

> **Agent 不是人。Agent 之间没有"实时对话"的需求。**
>
> 每个 Agent 独立运行在不同的机器上，通过 Slack 消息异步通信。
> 不存在"同时在线"的概念，不需要也不应该协调时间。

- **Slack 文字消息** = 唯一协作方式（任务下达、讨论、状态同步、验收确认）
- **Git** = 代码/文档协作
- 每个 Agent 完全独立，无共享文件系统

### 禁止实时协作行为

以下行为是对 Agent 本质的误用，**严格禁止**：

| 禁止行为 | 正确做法 |
|---------|---------|
| 发起 Slack Huddle / 会议 | 在 thread 中异步讨论 |
| 讨论"几点有空"、约时间 | 直接发消息，对方看到就回复 |
| 安排"定期会议"、"同步会议" | 用 Canvas 做持久化状态看板，各自读取 |
| 等所有人"到齐"再讨论 | 每人在 thread 中独立发表意见，够了就决策 |
| 说"我们开个会讨论一下" | 直接在 thread 中列出问题 + 方案，@mention 相关方各自回复 |

### 多方讨论的正确方式

当一个问题需要多个 Agent 参与时：

1. 发起方在 thread 中 @mention 所有相关 Agent
2. 清晰列出：**问题 + 选项 + 各选项 trade-off**
3. 每个被 @mention 的 Agent **独立回复自己的意见**（不需要等其他人先回复）
4. 收集到足够意见后，由决策者（参见 §6.4 冲突解决）做出决策
5. 决策者在 thread 中总结决策结果

### 收到任务时的三段式回复

所有执行层 Agent 收到任务时，采用统一的三段式流程：

1. **回复**：收到 + 执行计划（步骤）+ 预期产出路径/链接 + 风险/依赖
2. **执行**：多步或有副作用时优先用 Lobster workflow（可审批/可恢复）
3. **回复**：执行完成后回报实际产出路径/链接 + 证据（commit/截图/URL）

---

## 10. 执行模式：先做后说

### 核心原则

> **每条 Slack 消息都会触发对方 Agent 被唤醒（= 一次 LLM 调用）。**
> 过度沟通 = 频繁相互触发 = 成本高 + 效率低 + 来回拉扯。
>
> **正确做法：收到任务后尽最大可能自主完成，只在真正需要外部输入时才发消息。**

### 执行层 Agent 的工作模式

```
收到任务
    ↓
快速确认"收到"（1 条消息）
    ↓
【沉默执行】← 在本地长时间自主工作
    ↓
遇到真正的阻塞？→ 发消息求助（说清问题 + 已尝试的方案）
    ↓
完成 → 发完成通知（1 条消息，含完整产出）
```

**理想情况下，一个任务只触发 2 条消息：收到 + 完成。**

### 什么时候该发消息（✅）

| 场景 | 消息内容 |
|------|---------|
| 确认收到任务 | "收到，开始执行" + 简要计划 |
| 真正被阻塞（缺少依赖、权限不足） | 问题 + 已尝试 + 需要什么 |
| 发现任务理解有重大歧义 | 具体歧义点 + 两种理解 + 你倾向哪个 |
| 长任务进度更新（>2h 的任务） | 🚧 进度：已完成 X / 共 Y 步 |
| 任务完成 | 完整产出 + 证据 |

### 什么时候不该发消息（❌）

| 禁止行为 | 正确做法 |
|---------|---------|
| 每做完一小步就汇报 | 攒到完成再汇报 |
| 遇到小问题就求助（可以自己查文档/代码解决） | 先自己尝试，解决不了再求助 |
| 确认理解后再确认、再再确认 | 确认一次就开始做 |
| 反复讨论方案不动手 | 快速选一个方案先做，做完了不对再改 |
| 转述别人说的话给另一个人 | 让相关方直接沟通（§6.2 直接技术协作通道） |
| 问"这样做可以吗"（你有权自主决策的事） | 直接做，参考 §7 决策分级 |

### 长任务的进度更新（Cron 驱动）

对于需要长时间执行的任务（如开发一个前端模块），Agent 应利用 OpenClaw 的 Cron 机制自动汇报进度：

**执行层 Agent 的 Heartbeat 中自动检查：**
1. 读取当前任务状态（Canvas / 本地 MEMORY.md）
2. 如果有正在进行的长任务 → 在任务 thread 中更新进度
3. 格式：`🚧 进度：[已完成的] / [计划的]，当前在做 [什么]，无阻塞`
4. 如果有阻塞 → 升级

**进度更新频率：**
- 不需要人为控制频率 — Heartbeat 触发时自然更新
- 只在有实质进展或状态变化时才更新，无变化不发消息

### 对话效率规则

#### 提问必须自带方案

❌ "这个接口应该怎么设计？"
✅ "这个接口我倾向方案 A（理由），但方案 B 也可行（理由），你看选哪个？"

#### 一次说完所有问题

❌ 连续发 3 条消息，每条问一个问题
✅ 一条消息列出所有问题，让对方一次回完

#### 回复必须推进事情

❌ "好的，收到，我看看"（没有任何推进）
✅ "收到，我选方案 A，现在开始实现，预计产出在 projects/xxx/src/"
